<?php
/**
 * @file
 * Code for the GIE Dashboard feature.
 */

include_once 'gie_dashboard.features.inc';


/*
 * Implements hook_ctools_plugin_directory()
 */
function gie_dashboard_ctools_plugin_directory($owner, $plugin_type) {
  if ($owner == 'ctools' && $plugin_type == 'content_types') {
    return 'plugins/' . $plugin_type;
  }
}

/**
 * Implements hook_search_api_solr_query_alter().
 *
 * Adds multiple IDs for MLT call
 */
function gie_dashboard_search_api_solr_query_alter(array &$call_args, SearchApiQueryInterface $query) {
  $id = search_api_solr_site_hash();
  $nids =  &drupal_static('_mlt_nids');
  $node_index = 'id:"' . $id . '-default_node_index-' . $nids[0] . '"';

  // Make sure it's the query we want, could also check reference of query
  if ($node_index == $call_args['query']) {
    $index = 1;
    $count = count($nids);

    $call_args['query'] = 'id:(';
    foreach ($nids as $nid) {
      $call_args['query'] .= '"' . $id . '-default_node_index-' . $nid . '"';
      if ($index < $count) {
        $call_args['query'] .= ' OR ';
      }
      $index++;
    }
    $call_args['query'] .= ')';
  }
}


/**
 * TODO: Combine Queries to reduce time for creation
 */
function gie_dashboard_notification_center_list() {
  global $user;
  $results = array();
  $follow_user = flag_load('follow');

  //  Comments left on your content
  $results['comments_on_your_content'] = db_query('SELECT SUM(comment_count) FROM node INNER JOIN node_comment_statistics ON node_comment_statistics.nid = node.nid WHERE uid = :uid', array(':uid' => $user->uid))->fetchField();

  // Users following you
  $results['people_follow_you'] = gie_dashboard_flag_get_entity_flag_counts($follow_user, 'user', array(
    'entity_id',
    $user->uid
  ));

  // Users following your content
  $results['people_follow_your_content'] = db_query('SELECT COUNT(node.nid) FROM node INNER JOIN flagging on flagging.entity_id = node.nid WHERE node.uid = :uid AND flagging.uid <> :uid', array(':uid' => $user->uid))->fetchField();

  // Grab a random followers for use with generating a list of content
  $followers = db_query('SELECT flagging.uid FROM flagging WHERE flagging.fid = :fid AND flagging.entity_id = :uid', array(
    ':fid' => $follow_user->fid,
    ':uid' => $user->uid
  ))->fetchCol();

  //  A "friend" created new content
  $results['friend_content'] = db_query('SELECT node.title, node.nid, users.name
  FROM node
  INNER JOIN users on users.uid = node.uid
  WHERE node.uid IN (:uids) AND node.changed between :start AND :end
  ORDER BY RAND() LIMIT 1', array(
    ':uids' => $followers,
    ':start' => strtotime('first day of last month'),
    ':end' => strtotime('now')
  ))->fetchAssoc();

  //  A "friend" followed a piece of content
  $results['friend_followed_content'] = db_query('SELECT users.name, followed_content.title, followed_content.nid
  FROM flagging
  INNER JOIN users on users.uid = flagging.uid
  INNER JOIN node followed_content on followed_content.nid = flagging.entity_id AND flagging.timestamp between :start AND :end
  WHERE flagging.uid IN (:uids) ORDER BY RAND() LIMIT 1', array(
    ':start' => strtotime('first day of last month'),
    ':end' => strtotime('now'),
    ':uids' => $followers
  ))->fetchAssoc();

  //  A "friend" connected with a user
  $results['friend_followed'] = db_query('SELECT users.name as original_friend, friend_of_friend.uid, friend_of_friend.name as friend_of_friend
  FROM flagging
  INNER JOIN users on users.uid = flagging.uid
  INNER JOIN flagging connected_user on connected_user.uid = flagging.entity_id AND flagging.timestamp between :start AND :end
  INNER JOIN users friend_of_friend on friend_of_friend.uid = connected_user.uid
  WHERE flagging.uid IN (:uids) AND flagging.fid = :fid AND connected_user.fid = :fid ORDER BY RAND() LIMIT 1', array(
    ':start' => strtotime('first day of last month'),
    ':end' => strtotime('now'),
    ':uids' => $followers,
    ':fid' => $follow_user->fid
  ))->fetchAssoc();


  //  A "friend" commented on content
  $results['friend_comment'] = db_query('  SELECT users.name, node.title, node.nid, friend_comment.subject
  FROM users
  INNER JOIN comment friend_comment on friend_comment.uid = users.uid AND friend_comment.changed between :start AND :end
  INNER JOIN node on node.nid = friend_comment.nid
  WHERE users.uid IN (:uids)
  ORDER BY RAND()
  LIMIT 1 ', array(
    ':uids' => $followers,
    ':start' => strtotime('first day of last month'),
    ':end' => strtotime('now')
  ))->fetchAssoc();

  //TODO: See if needed later on, if not remove
  //  $favorite = flag_load('favorite');
  //  $follow_taxonomy = flag_load('follow_taxonomy');
//  $attending = flag_load('attending');
//  $results['exchange_updates'] = drupal_render(drupal_get_form('gie_dashboard_exchange_updates_form'));

//  // People you follow
//  $results['people_you_follow'] = gie_dashboard_flag_get_entity_flag_counts($follow_user, 'user', array(
//    'uid',
//    $user->uid
//  ));
//
//  //Number of events you are attending
//  $results['attending_counts'] = gie_dashboard_flag_get_entity_flag_counts($attending, 'node', array(
//    'uid',
//    $user->uid
//  ));
//
//  // Favorite counts for event, funding, innovation, long_form_page, needs, organization, program, resource
//  $results['favorite_counts'] = gie_dashboard_flag_get_entity_flag_counts($favorite, 'node', array(
//    'uid',
//    $user->uid
//  ));
//
//  // People you follow
//  $results['people_you_follow'] = gie_dashboard_flag_get_entity_flag_counts($follow_user, 'user', array(
//    'uid',
//    $user->uid
//  ));
//
//
//  //Follow region, topic, sector, program_discussions
//  $results['follow_taxonomy_counts'] = gie_dashboard_flag_get_entity_flag_counts($follow_taxonomy, 'taxonomy_term', array(
//    'uid',
//    $user->uid
//  ));
//
//  //Number of events you are attending
//  $results['attending_counts'] = gie_dashboard_flag_get_entity_flag_counts($attending, 'node', array(
//    'uid',
//    $user->uid
//  ));



  return $results;
}

///**
// * @param $variables
// */
//function template_preprocess_gie_dashboard_whats_new_notification_center_view(&$variables) {
//  foreach ($variables['results'] as $key => $result) {
//    if ($key == 'comments_on_your_content') {
//      $variables['results'][$key] = $result . ' People have commented on your content.';
//    }
//    if ($key == 'people_follow_your_content') {
//      $variables['results'][$key] = $result . ' People follow your content.';
//    }
//    elseif ($key == 'people_follow_you') {
//      $variables['results'][$key] = $result . ' People follow you.';
//    }
//    elseif ($key == 'friend_content') {
//      $variables['results'][$key] = $result['name'] . ' created new content ' . l($result['title'], 'node/' . $result['nid']) . '.';
//    }
//    elseif ($key == 'friend_followed_content') {
//      $variables['results'][$key] = $result['name'] . ' followed content ' . l($result['title'], 'node/' . $result['nid']) . '.';
//    }
//    elseif ($key == 'friend_followed') {
//      $variables['results'][$key] = $result['original_friend'] . ' followed ' . $result['friend_of_friend'] . '.';
//    }
//    elseif ($key == 'friend_comment') {
//      $variables['results'][$key] = $result['name'] . ' commented ' . $result['subject'] . ' on ' . l($result['title'], 'node/' . $result['nid']) . '.';
//    }
//  }
//}
//
//
///**
// * @return array|string
// * @throws \Exception
// */
//function gie_dashboard_whats_new_notification_center() {
//  $results = gie_dashboard_notification_center_list();
//  if ($results) {
//    $results = theme('gie_dashboard_whats_new_notification_center_view', array('results' => $results));
//    return $results;
//  }
//  else {
//    return 'empty data';
//  }
//}

/**
 *
 * Implements hook_form_FORM_ID_alter().
 */
function gie_dashboard_form_innovation_node_form_alter(&$form, &$form_state) {
  $admin_role = user_role_load_by_name('administrator');
  $community_role = user_role_load_by_name('Program Community Manager');
  if (!(user_has_role($admin_role->rid) || user_has_role($community_role->rid))) {
    $form['field_featured_innovation']['#type'] = 'hidden';
  }
  // Set field visibility based on whether the user is an admin
  $form['#validate'][] = 'gie_dashboard_form_validate';
}


/**va
 * @param $form
 * @param $form_state
 */
function gie_dashboard_form_validate($form, &$form_state) {
  if (!empty($form_state['values']['field_featured_innovation'][LANGUAGE_NONE][0]['value'])) {
    if ($form_state['values']['field_featured_innovation']['und'][0]['value'] == 1) {
      $existing_featured_innovation = db_query('SELECT entity_id FROM field_data_field_featured_innovation WHERE field_featured_innovation_value = 1')->fetchField();
      if (!empty($existing_featured_innovation)) {
        form_set_error('field_featured_innovation', 'Only one Innovation can be featured at a time. Here is the current ' . l('Featured Innovation', 'node/' . $existing_featured_innovation . '/edit'));
      }
    }
  }
}

/**
 *
 * Get the count of flags for a particular entity type.
 *
 * When called during a flagging or unflagging (such as from a hook
 * implementation or from Rules), the flagging or unflagging that is in the
 * process of being performed:
 *  - will be included during a flagging operation
 *  - will STILL be included during an unflagging operation. That is, the count
 *    will not yet have been decreased.
 * This is because this queries the {flagging} table, which only has its record
 * deleted at the very end of the unflagging process.
 *
 * @param $flag
 *   The flag.
 * @param $entity_type
 *   The entity type. For example, 'node'.
 * @param $condition
 *   The condition. For example, array('uid', $user->uid).
 *
 * @return
 *   The flag count with the flag name and entity type as the array key.
 */
function gie_dashboard_flag_get_entity_flag_counts($flag, $entity_type, $condition) {
  $counts = &drupal_static(__FUNCTION__);

  // We check to see if the flag count is already in the cache,
  // if it's not, run the query.
  if (!isset($counts[$flag->name][$entity_type])) {
    $counts[$flag->name][$entity_type] = array();
    $result = db_select('flagging', 'f')
      ->fields('f', array('fid'))
      ->condition('fid', $flag->fid)
      ->condition('entity_type', $entity_type)
      ->condition("$condition[0]", "$condition[1]")
      ->countQuery()
      ->execute()
      ->fetchField();
    $counts[$flag->name][$entity_type] = $result;
  }

  return $counts[$flag->name][$entity_type];
}


